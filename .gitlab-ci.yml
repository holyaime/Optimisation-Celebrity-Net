# You can override the included template(s) by including variable overrides
# SAST customization: https://docs.gitlab.com/ee/user/application_security/sast/#customizing-the-sast-settings
# Secret Detection customization: https://docs.gitlab.com/ee/user/application_security/secret_detection/pipeline/#customization
# Dependency Scanning customization: https://docs.gitlab.com/ee/user/application_security/dependency_scanning/#customizing-the-dependency-scanning-settings
# Container Scanning customization: https://docs.gitlab.com/ee/user/application_security/container_scanning/#customizing-the-container-scanning-settings
# Note that environment variables can be set in several places
# See https://docs.gitlab.com/ee/ci/variables/#cicd-variable-precedence
stages:
- quality_check
- test
- security
- requirements
- build
- develop
- production

variables:
  IMAGE_NAME: datakori/celebrity-ai
  IMAGE_TAG: v1.0.1
  LATEST: latest
  APPLICATION_NAME: celebrity-ai
  CONTAINER_PORT: 5001
  SERVER_PORT: 8000
  APP_LOCATION: /home/$SERVER_USER/$APPLICATION_NAME/
  DEV_SERVER_ADDRESS: http://celebrity-ai.dev.datakori.tech
  PROD_SERVER_ADDRESS: http://celebrity-ai.prod.datakori.tech
  MAIN_BRANCH: release
  DEV_BRANCH: develop

include:
  - project: 'DATAKORI/ops/ci-templates'
    file: 'pipeline.yml'

# disallow download of cache for our default job in upstream
.no_previous_cache:
  cache: []

requirements:
  image: datakori/poetry
  stage: requirements
  script:
    - poetry export -f requirements.txt --only main --without-hashes --without-urls -o requirements.txt
    - poetry build
  artifacts:
    paths:
      - requirements.txt
      - dist/*.whl
  rules:
    - if: $CI_COMMIT_BRANCH == $MAIN_BRANCH
    - if: $CI_COMMIT_BRANCH == $DEV_BRANCH

build_prod_image:
  stage: build
  image: docker:26.0.0-rc2-cli
  extends: .no_previous_cache
  services:
    - docker:26.0.0-rc2-dind

  variables:
    DOCKER_TLS_CERTDIR: "/certs"

  before_script:
    - apk add make
    - echo $REGISTRY_ACCESS_KEY | docker login -u $REGISTRY_USER --password-stdin

  script:
    # Docker Hub
    - make build_pipeline IMAGE_NAME=$IMAGE_NAME IMAGE_TAG=$IMAGE_TAG
    - docker tag $IMAGE_NAME:$IMAGE_TAG $IMAGE_NAME:$LATEST
    - docker push $IMAGE_NAME:$IMAGE_TAG
    - docker push $IMAGE_NAME:$LATEST

  after_script:
    - docker logout

  rules:
    - if: $CI_COMMIT_BRANCH == $MAIN_BRANCH
      when: manual

build_dev_image:
  extends:
  - build_prod_image
  - .no_previous_cache

  script:
    - make build_pipeline IMAGE_NAME=$IMAGE_NAME IMAGE_TAG=DEV-$CI_COMMIT_SHORT_SHA
    - docker tag $IMAGE_NAME:DEV-$CI_COMMIT_SHORT_SHA $IMAGE_NAME:DEV-latest
    - docker push $IMAGE_NAME:DEV-$CI_COMMIT_SHORT_SHA
    - docker push $IMAGE_NAME:DEV-latest

  rules:
    - if: $CI_COMMIT_BRANCH == $MAIN_BRANCH
      when: always

    - if: $CI_COMMIT_BRANCH == $DEV_BRANCH
      when: manual

# deploy to yann
deploy-to-dev:
  image: alpine:latest
  stage: develop
  extends: .no_previous_cache
  script:
    - echo "Deploy to staging server"
    - chmod og= $ID_RSA
    - apk update && apk add openssh-client
    - ssh -i $ID_RSA -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP "echo $REGISTRY_ACCESS_KEY | docker login -u $REGISTRY_USER --password-stdin"
    - ssh -i $ID_RSA -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP "docker pull $IMAGE_NAME:DEV-latest"
    - ssh -i $ID_RSA -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP "rm -fr $APP_LOCATION && mkdir -p $APP_LOCATION"
    - scp -i $ID_RSA -o StrictHostKeyChecking=no docker-compose.yml deploy.sh $SERVER_USER@$SERVER_IP:$APP_LOCATION
    - |
      ssh -i $ID_RSA -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP \
      "export APPLICATION_NAME=$APPLICATION_NAME IMAGE_NAME=$IMAGE_NAME \
      IMAGE_TAG=DEV-latest CONTAINER_PORT=$CONTAINER_PORT SERVER_PORT=$SERVER_PORT \
      && cd $APP_LOCATION && sh deploy.sh && rm deploy.sh"

  environment:
    name: develop
    url: $DEV_SERVER_ADDRESS

  rules:
    - if: $CI_COMMIT_BRANCH == $MAIN_BRANCH
    - if: $CI_COMMIT_BRANCH == $DEV_BRANCH

  needs:
    - build_dev_image

# deploy to sankara
deploy-to-prod:
  image: alpine:latest
  stage: production
  extends: .no_previous_cache
  script:
    - echo "Deploy to production server"
    - chmod og= $ID_RSA_PROD
    - apk update && apk add openssh-client
    - ssh -i $ID_RSA_PROD -o StrictHostKeyChecking=no $SERVER_USER@$PROD_SERVER_IP "echo $REGISTRY_ACCESS_KEY | docker login -u $REGISTRY_USER --password-stdin"
    - ssh -i $ID_RSA_PROD -o StrictHostKeyChecking=no $SERVER_USER@$PROD_SERVER_IP "docker pull $IMAGE_NAME:$LATEST"
    - ssh -i $ID_RSA_PROD -o StrictHostKeyChecking=no $SERVER_USER@$PROD_SERVER_IP "docker container rm -f $APPLICATION_NAME || true"
    - ssh -i $ID_RSA_PROD -o StrictHostKeyChecking=no $SERVER_USER@$PROD_SERVER_IP "docker run -d -p $SERVER_PORT:$CONTAINER_PORT --name $APPLICATION_NAME $IMAGE_NAME:$LATEST"

  environment:
    name: production
    url: $PROD_SERVER_ADDRESS

  rules:
    - if: $CI_COMMIT_BRANCH == $MAIN_BRANCH

  needs:
    - build_prod_image
